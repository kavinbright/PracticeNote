## 1. 简单工厂模式
- 包含一个抽象类(Base.php)，抽象类中定义一些抽象方法
```php
<?php
abstract class Base
{
    abstract public function operate($a, $b);
}
```
- 子类继承抽象类，并实现抽象方法
```php
<?php
include_once "Base.php";
class OperationAdd extends Base
{
    public function operate($a, $b){
        return $a+$b;
    }

}
```

```php
<?php
include_once "Base.php";
class OperationSub extends Base
{
    public function operate($a, $b){
        return $a+$b;
    }

}
```
- 工厂类根据参数自动实例化子类对象
```php
<?php
include_once "OperationAdd.php";
include_once "OperationSub.php";
class Factory
{

    public static function createObj($oper){
        $obj = "";
        switch ($oper){
            case '+':
                $obj = new OperationAdd();
                break;
            case "-":
                $obj = new OperationSub();
                break;
        }
        return $obj;
    }
}
```
- 使用
```php
include_once "Factory.php";
$oper = "+";
$obj = Factory::createObj($oper);
$obj->operate(1,2);
```
____________________

## 2. 观察者模式
- 观察者利用主题进行注册对象
- 主题利用观察者接口提供观察者。
```php
<?php
//主题
class Theme{
    private $_observers = array();

    public function register($sub){ /*  注册观察者 */
        $this->_observers[] = $sub;
    }


    public function trigger(){  /*  外部统一访问    */
        if(!empty($this->_observers)){
            foreach($this->_observers as $observer){
                $observer->update();
            }
        }
    }
}

//观察者接口
/**
 * 观察者要实现的接口
 */
interface Observerable{
    public function update();
}

//观察者1
class Subscriber1 implements Observerable{
    public function update(){
        echo "Observe_01\n";
    }
}


//观察者2
class Subscriber2 implements Observerable{
    public function update(){
        echo "Observe_02\n";
    }
}

//测试
$paper = new Paper();
$paper->register(new Subscriber1());
$paper->register(new Subscriber2());
$paper->trigger();

```
____________________________
## 3.单例模式
- 抽象基类：类中定义抽象一些方法，用以在子类中实现
- 继承自抽象基类的子类：实现基类中的抽象方法
- 工厂类：用以实例化所有相对应的子类
```php
<?php

class Single{
     private static $_instance;
     private function __construct()
     {
         return;
     }
     private function __clone()
     {
         return;
     }

     public static function get_instance(){
         if(!isset(self::$_instance)){
             self::$_instance = new self();
         }
         return self::$_instance;
     }

     function test(){
         return "test";
     }

}
```
